apiVersion: v1
items:
- apiVersion: v1
  data:
    queries: |
      backends:
        query: |
         SELECT sa.datname
             , sa.usename
             , sa.application_name
             , states.state
             , COALESCE(sa.count, 0) AS total
             , COALESCE(sa.max_tx_secs, 0) AS max_tx_duration_seconds
             FROM ( VALUES ('active')
                 , ('idle')
                 , ('idle in transaction')
                 , ('idle in transaction (aborted)')
                 , ('fastpath function call')
                 , ('disabled')
                 ) AS states(state)
             LEFT JOIN (
                 SELECT datname
                     , state
                     , usename
                     , COALESCE(application_name, '') AS application_name
                     , COUNT(*)
                     , COALESCE(EXTRACT (EPOCH FROM (max(now() - xact_start))), 0) AS max_tx_secs
                 FROM pg_catalog.pg_stat_activity
                 GROUP BY datname, state, usename, application_name
             ) sa ON states.state = sa.state
             WHERE sa.usename IS NOT NULL
        metrics:
          - datname:
              usage: "LABEL"
              description: "Name of the database"
          - usename:
              usage: "LABEL"
              description: "Name of the user"
          - application_name:
              usage: "LABEL"
              description: "Name of the application"
          - state:
              usage: "LABEL"
              description: "State of the backend"
          - total:
              usage: "GAUGE"
              description: "Number of backends"
          - max_tx_duration_seconds:
              usage: "GAUGE"
              description: "Maximum duration of a transaction in seconds"

      backends_waiting:
        query: |
         SELECT count(*) AS total
         FROM pg_catalog.pg_locks blocked_locks
         JOIN pg_catalog.pg_locks blocking_locks
           ON blocking_locks.locktype = blocked_locks.locktype
           AND blocking_locks.database IS NOT DISTINCT FROM blocked_locks.database
           AND blocking_locks.relation IS NOT DISTINCT FROM blocked_locks.relation
           AND blocking_locks.page IS NOT DISTINCT FROM blocked_locks.page
           AND blocking_locks.tuple IS NOT DISTINCT FROM blocked_locks.tuple
           AND blocking_locks.virtualxid IS NOT DISTINCT FROM blocked_locks.virtualxid
           AND blocking_locks.transactionid IS NOT DISTINCT FROM blocked_locks.transactionid
           AND blocking_locks.classid IS NOT DISTINCT FROM blocked_locks.classid
           AND blocking_locks.objid IS NOT DISTINCT FROM blocked_locks.objid
           AND blocking_locks.objsubid IS NOT DISTINCT FROM blocked_locks.objsubid
           AND blocking_locks.pid != blocked_locks.pid
         JOIN pg_catalog.pg_stat_activity blocking_activity ON blocking_activity.pid = blocking_locks.pid
         WHERE NOT blocked_locks.granted
        metrics:
          - total:
              usage: "GAUGE"
              description: "Total number of backends that are currently waiting on other queries"

      pg_database:
        query: |
          SELECT datname
            , pg_catalog.pg_database_size(datname) AS size_bytes
            , pg_catalog.age(datfrozenxid) AS xid_age
            , pg_catalog.mxid_age(datminmxid) AS mxid_age
          FROM pg_catalog.pg_database
        metrics:
          - datname:
              usage: "LABEL"
              description: "Name of the database"
          - size_bytes:
              usage: "GAUGE"
              description: "Disk space used by the database"
          - xid_age:
              usage: "GAUGE"
              description: "Number of transactions from the frozen XID to the current one"
          - mxid_age:
              usage: "GAUGE"
              description: "Number of multiple transactions (Multixact) from the frozen XID to the current one"

      pg_postmaster:
        query: |
          SELECT EXTRACT(EPOCH FROM pg_postmaster_start_time) AS start_time
          FROM pg_catalog.pg_postmaster_start_time()
        metrics:
          - start_time:
              usage: "GAUGE"
              description: "Time at which postgres started (based on epoch)"

      pg_replication:
        query: "SELECT CASE WHEN NOT pg_catalog.pg_is_in_recovery()
                THEN 0
                ELSE GREATEST (0,
                  EXTRACT(EPOCH FROM (now() - pg_catalog.pg_last_xact_replay_timestamp())))
                END AS lag,
                pg_catalog.pg_is_in_recovery() AS in_recovery,
                EXISTS (TABLE pg_stat_wal_receiver) AS is_wal_receiver_up,
                (SELECT count(*) FROM pg_stat_replication) AS streaming_replicas"
        metrics:
          - lag:
              usage: "GAUGE"
              description: "Replication lag behind primary in seconds"
          - in_recovery:
              usage: "GAUGE"
              description: "Whether the instance is in recovery"
          - is_wal_receiver_up:
              usage: "GAUGE"
              description: "Whether the instance wal_receiver is up"
          - streaming_replicas:
              usage: "GAUGE"
              description: "Number of streaming replicas connected to the instance"

      pg_replication_slots:
        query: |
          SELECT slot_name,
            slot_type,
            database,
            active,
            pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), restart_lsn)
          FROM pg_catalog.pg_replication_slots
          WHERE NOT temporary
        metrics:
          - slot_name:
              usage: "LABEL"
              description: "Name of the replication slot"
          - slot_type:
              usage: "LABEL"
              description: "Type of the replication slot"
          - database:
              usage: "LABEL"
              description: "Name of the database"
          - active:
              usage: "GAUGE"
              description: "Flag indicating whether the slot is active"
          - pg_wal_lsn_diff:
              usage: "GAUGE"
              description: "Replication lag in bytes"

      pg_stat_archiver:
        query: |
          SELECT archived_count
            , failed_count
            , COALESCE(EXTRACT(EPOCH FROM (now() - last_archived_time)), -1) AS seconds_since_last_archival
            , COALESCE(EXTRACT(EPOCH FROM (now() - last_failed_time)), -1) AS seconds_since_last_failure
            , COALESCE(EXTRACT(EPOCH FROM last_archived_time), -1) AS last_archived_time
            , COALESCE(EXTRACT(EPOCH FROM last_failed_time), -1) AS last_failed_time
            , COALESCE(CAST(CAST('x'||pg_catalog.right(pg_catalog.split_part(last_archived_wal, '.', 1), 16) AS pg_catalog.bit(64)) AS pg_catalog.int8), -1) AS last_archived_wal_start_lsn
            , COALESCE(CAST(CAST('x'||pg_catalog.right(pg_catalog.split_part(last_failed_wal, '.', 1), 16) AS pg_catalog.bit(64)) AS pg_catalog.int8), -1) AS last_failed_wal_start_lsn
            , EXTRACT(EPOCH FROM stats_reset) AS stats_reset_time
          FROM pg_catalog.pg_stat_archiver
        metrics:
          - archived_count:
              usage: "COUNTER"
              description: "Number of WAL files that have been successfully archived"
          - failed_count:
              usage: "COUNTER"
              description: "Number of failed attempts for archiving WAL files"
          - seconds_since_last_archival:
              usage: "GAUGE"
              description: "Seconds since the last successful archival operation"
          - seconds_since_last_failure:
              usage: "GAUGE"
              description: "Seconds since the last failed archival operation"
          - last_archived_time:
              usage: "GAUGE"
              description: "Epoch of the last time WAL archiving succeeded"
          - last_failed_time:
              usage: "GAUGE"
              description: "Epoch of the last time WAL archiving failed"
          - last_archived_wal_start_lsn:
              usage: "GAUGE"
              description: "Archived WAL start LSN"
          - last_failed_wal_start_lsn:
              usage: "GAUGE"
              description: "Last failed WAL LSN"
          - stats_reset_time:
              usage: "GAUGE"
              description: "Time at which these statistics were last reset"

      pg_stat_bgwriter:
        query: |
          SELECT checkpoints_timed
            , checkpoints_req
            , checkpoint_write_time
            , checkpoint_sync_time
            , buffers_checkpoint
            , buffers_clean
            , maxwritten_clean
            , buffers_backend
            , buffers_backend_fsync
            , buffers_alloc
          FROM pg_catalog.pg_stat_bgwriter
        metrics:
          - checkpoints_timed:
              usage: "COUNTER"
              description: "Number of scheduled checkpoints that have been performed"
          - checkpoints_req:
              usage: "COUNTER"
              description: "Number of requested checkpoints that have been performed"
          - checkpoint_write_time:
              usage: "COUNTER"
              description: "Total amount of time that has been spent in the portion of checkpoint processing where files are written to disk, in milliseconds"
          - checkpoint_sync_time:
              usage: "COUNTER"
              description: "Total amount of time that has been spent in the portion of checkpoint processing where files are synchronized to disk, in milliseconds"
          - buffers_checkpoint:
              usage: "COUNTER"
              description: "Number of buffers written during checkpoints"
          - buffers_clean:
              usage: "COUNTER"
              description: "Number of buffers written by the background writer"
          - maxwritten_clean:
              usage: "COUNTER"
              description: "Number of times the background writer stopped a cleaning scan because it had written too many buffers"
          - buffers_backend:
              usage: "COUNTER"
              description: "Number of buffers written directly by a backend"
          - buffers_backend_fsync:
              usage: "COUNTER"
              description: "Number of times a backend had to execute its own fsync call (normally the background writer handles those even when the backend does its own write)"
          - buffers_alloc:
              usage: "COUNTER"
              description: "Number of buffers allocated"

      pg_stat_database:
        query: |
          SELECT datname
            , xact_commit
            , xact_rollback
            , blks_read
            , blks_hit
            , tup_returned
            , tup_fetched
            , tup_inserted
            , tup_updated
            , tup_deleted
            , conflicts
            , temp_files
            , temp_bytes
            , deadlocks
            , blk_read_time
            , blk_write_time
          FROM pg_catalog.pg_stat_database
        metrics:
          - datname:
              usage: "LABEL"
              description: "Name of this database"
          - xact_commit:
              usage: "COUNTER"
              description: "Number of transactions in this database that have been committed"
          - xact_rollback:
              usage: "COUNTER"
              description: "Number of transactions in this database that have been rolled back"
          - blks_read:
              usage: "COUNTER"
              description: "Number of disk blocks read in this database"
          - blks_hit:
              usage: "COUNTER"
              description: "Number of times disk blocks were found already in the buffer cache, so that a read was not necessary (this only includes hits in the PostgreSQL buffer cache, not the operating system's file system cache)"
          - tup_returned:
              usage: "COUNTER"
              description: "Number of rows returned by queries in this database"
          - tup_fetched:
              usage: "COUNTER"
              description: "Number of rows fetched by queries in this database"
          - tup_inserted:
              usage: "COUNTER"
              description: "Number of rows inserted by queries in this database"
          - tup_updated:
              usage: "COUNTER"
              description: "Number of rows updated by queries in this database"
          - tup_deleted:
              usage: "COUNTER"
              description: "Number of rows deleted by queries in this database"
          - conflicts:
              usage: "COUNTER"
              description: "Number of queries canceled due to conflicts with recovery in this database"
          - temp_files:
              usage: "COUNTER"
              description: "Number of temporary files created by queries in this database"
          - temp_bytes:
              usage: "COUNTER"
              description: "Total amount of data written to temporary files by queries in this database"
          - deadlocks:
              usage: "COUNTER"
              description: "Number of deadlocks detected in this database"
          - blk_read_time:
              usage: "COUNTER"
              description: "Time spent reading data file blocks by backends in this database, in milliseconds"
          - blk_write_time:
              usage: "COUNTER"
              description: "Time spent writing data file blocks by backends in this database, in milliseconds"

      pg_stat_replication:
        primary: true
        query: |
         SELECT usename
           , COALESCE(application_name, '') AS application_name
           , COALESCE(client_addr::text, '') AS client_addr
           , EXTRACT(EPOCH FROM backend_start) AS backend_start
           , COALESCE(pg_catalog.age(backend_xmin), 0) AS backend_xmin_age
           , pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), sent_lsn) AS sent_diff_bytes
           , pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), write_lsn) AS write_diff_bytes
           , pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), flush_lsn) AS flush_diff_bytes
           , COALESCE(pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), replay_lsn),0) AS replay_diff_bytes
           , COALESCE((EXTRACT(EPOCH FROM write_lag)),0)::float AS write_lag_seconds
           , COALESCE((EXTRACT(EPOCH FROM flush_lag)),0)::float AS flush_lag_seconds
           , COALESCE((EXTRACT(EPOCH FROM replay_lag)),0)::float AS replay_lag_seconds
         FROM pg_catalog.pg_stat_replication
        metrics:
          - usename:
              usage: "LABEL"
              description: "Name of the replication user"
          - application_name:
              usage: "LABEL"
              description: "Name of the application"
          - client_addr:
              usage: "LABEL"
              description: "Client IP address"
          - backend_start:
              usage: "COUNTER"
              description: "Time when this process was started"
          - backend_xmin_age:
              usage: "COUNTER"
              description: "The age of this standby's xmin horizon"
          - sent_diff_bytes:
              usage: "GAUGE"
              description: "Difference in bytes from the last write-ahead log location sent on this connection"
          - write_diff_bytes:
              usage: "GAUGE"
              description: "Difference in bytes from the last write-ahead log location written to disk by this standby server"
          - flush_diff_bytes:
              usage: "GAUGE"
              description: "Difference in bytes from the last write-ahead log location flushed to disk by this standby server"
          - replay_diff_bytes:
              usage: "GAUGE"
              description: "Difference in bytes from the last write-ahead log location replayed into the database on this standby server"
          - write_lag_seconds:
              usage: "GAUGE"
              description: "Time elapsed between flushing recent WAL locally and receiving notification that this standby server has written it"
          - flush_lag_seconds:
              usage: "GAUGE"
              description: "Time elapsed between flushing recent WAL locally and receiving notification that this standby server has written and flushed it"
          - replay_lag_seconds:
              usage: "GAUGE"
              description: "Time elapsed between flushing recent WAL locally and receiving notification that this standby server has written, flushed and applied it"

      pg_settings:
        query: |
          SELECT name,
          CASE setting WHEN 'on' THEN '1' WHEN 'off' THEN '0' ELSE setting END AS setting
          FROM pg_catalog.pg_settings
          WHERE vartype IN ('integer', 'real', 'bool')
          ORDER BY 1
        metrics:
          - name:
              usage: "LABEL"
              description: "Name of the setting"
          - setting:
              usage: "GAUGE"
              description: "Setting value"
  kind: ConfigMap
  metadata:
    annotations:
      kubectl.kubernetes.io/last-applied-configuration: |
        {"apiVersion":"v1","data":{"queries":"backends:\n  query: |\n   SELECT sa.datname\n       , sa.usename\n       , sa.application_name\n       , states.state\n       , COALESCE(sa.count, 0) AS total\n       , COALESCE(sa.max_tx_secs, 0) AS max_tx_duration_seconds\n       FROM ( VALUES ('active')\n           , ('idle')\n           , ('idle in transaction')\n           , ('idle in transaction (aborted)')\n           , ('fastpath function call')\n           , ('disabled')\n           ) AS states(state)\n       LEFT JOIN (\n           SELECT datname\n               , state\n               , usename\n               , COALESCE(application_name, '') AS application_name\n               , COUNT(*)\n               , COALESCE(EXTRACT (EPOCH FROM (max(now() - xact_start))), 0) AS max_tx_secs\n           FROM pg_catalog.pg_stat_activity\n           GROUP BY datname, state, usename, application_name\n       ) sa ON states.state = sa.state\n       WHERE sa.usename IS NOT NULL\n  metrics:\n    - datname:\n        usage: \"LABEL\"\n        description: \"Name of the database\"\n    - usename:\n        usage: \"LABEL\"\n        description: \"Name of the user\"\n    - application_name:\n        usage: \"LABEL\"\n        description: \"Name of the application\"\n    - state:\n        usage: \"LABEL\"\n        description: \"State of the backend\"\n    - total:\n        usage: \"GAUGE\"\n        description: \"Number of backends\"\n    - max_tx_duration_seconds:\n        usage: \"GAUGE\"\n        description: \"Maximum duration of a transaction in seconds\"\n\nbackends_waiting:\n  query: |\n   SELECT count(*) AS total\n   FROM pg_catalog.pg_locks blocked_locks\n   JOIN pg_catalog.pg_locks blocking_locks\n     ON blocking_locks.locktype = blocked_locks.locktype\n     AND blocking_locks.database IS NOT DISTINCT FROM blocked_locks.database\n     AND blocking_locks.relation IS NOT DISTINCT FROM blocked_locks.relation\n     AND blocking_locks.page IS NOT DISTINCT FROM blocked_locks.page\n     AND blocking_locks.tuple IS NOT DISTINCT FROM blocked_locks.tuple\n     AND blocking_locks.virtualxid IS NOT DISTINCT FROM blocked_locks.virtualxid\n     AND blocking_locks.transactionid IS NOT DISTINCT FROM blocked_locks.transactionid\n     AND blocking_locks.classid IS NOT DISTINCT FROM blocked_locks.classid\n     AND blocking_locks.objid IS NOT DISTINCT FROM blocked_locks.objid\n     AND blocking_locks.objsubid IS NOT DISTINCT FROM blocked_locks.objsubid\n     AND blocking_locks.pid != blocked_locks.pid\n   JOIN pg_catalog.pg_stat_activity blocking_activity ON blocking_activity.pid = blocking_locks.pid\n   WHERE NOT blocked_locks.granted\n  metrics:\n    - total:\n        usage: \"GAUGE\"\n        description: \"Total number of backends that are currently waiting on other queries\"\n\npg_database:\n  query: |\n    SELECT datname\n      , pg_catalog.pg_database_size(datname) AS size_bytes\n      , pg_catalog.age(datfrozenxid) AS xid_age\n      , pg_catalog.mxid_age(datminmxid) AS mxid_age\n    FROM pg_catalog.pg_database\n  metrics:\n    - datname:\n        usage: \"LABEL\"\n        description: \"Name of the database\"\n    - size_bytes:\n        usage: \"GAUGE\"\n        description: \"Disk space used by the database\"\n    - xid_age:\n        usage: \"GAUGE\"\n        description: \"Number of transactions from the frozen XID to the current one\"\n    - mxid_age:\n        usage: \"GAUGE\"\n        description: \"Number of multiple transactions (Multixact) from the frozen XID to the current one\"\n\npg_postmaster:\n  query: |\n    SELECT EXTRACT(EPOCH FROM pg_postmaster_start_time) AS start_time\n    FROM pg_catalog.pg_postmaster_start_time()\n  metrics:\n    - start_time:\n        usage: \"GAUGE\"\n        description: \"Time at which postgres started (based on epoch)\"\n\npg_replication:\n  query: \"SELECT CASE WHEN NOT pg_catalog.pg_is_in_recovery()\n          THEN 0\n          ELSE GREATEST (0,\n            EXTRACT(EPOCH FROM (now() - pg_catalog.pg_last_xact_replay_timestamp())))\n          END AS lag,\n          pg_catalog.pg_is_in_recovery() AS in_recovery,\n          EXISTS (TABLE pg_stat_wal_receiver) AS is_wal_receiver_up,\n          (SELECT count(*) FROM pg_stat_replication) AS streaming_replicas\"\n  metrics:\n    - lag:\n        usage: \"GAUGE\"\n        description: \"Replication lag behind primary in seconds\"\n    - in_recovery:\n        usage: \"GAUGE\"\n        description: \"Whether the instance is in recovery\"\n    - is_wal_receiver_up:\n        usage: \"GAUGE\"\n        description: \"Whether the instance wal_receiver is up\"\n    - streaming_replicas:\n        usage: \"GAUGE\"\n        description: \"Number of streaming replicas connected to the instance\"\n\npg_replication_slots:\n  query: |\n    SELECT slot_name,\n      slot_type,\n      database,\n      active,\n      pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), restart_lsn)\n    FROM pg_catalog.pg_replication_slots\n    WHERE NOT temporary\n  metrics:\n    - slot_name:\n        usage: \"LABEL\"\n        description: \"Name of the replication slot\"\n    - slot_type:\n        usage: \"LABEL\"\n        description: \"Type of the replication slot\"\n    - database:\n        usage: \"LABEL\"\n        description: \"Name of the database\"\n    - active:\n        usage: \"GAUGE\"\n        description: \"Flag indicating whether the slot is active\"\n    - pg_wal_lsn_diff:\n        usage: \"GAUGE\"\n        description: \"Replication lag in bytes\"\n\npg_stat_archiver:\n  query: |\n    SELECT archived_count\n      , failed_count\n      , COALESCE(EXTRACT(EPOCH FROM (now() - last_archived_time)), -1) AS seconds_since_last_archival\n      , COALESCE(EXTRACT(EPOCH FROM (now() - last_failed_time)), -1) AS seconds_since_last_failure\n      , COALESCE(EXTRACT(EPOCH FROM last_archived_time), -1) AS last_archived_time\n      , COALESCE(EXTRACT(EPOCH FROM last_failed_time), -1) AS last_failed_time\n      , COALESCE(CAST(CAST('x'||pg_catalog.right(pg_catalog.split_part(last_archived_wal, '.', 1), 16) AS pg_catalog.bit(64)) AS pg_catalog.int8), -1) AS last_archived_wal_start_lsn\n      , COALESCE(CAST(CAST('x'||pg_catalog.right(pg_catalog.split_part(last_failed_wal, '.', 1), 16) AS pg_catalog.bit(64)) AS pg_catalog.int8), -1) AS last_failed_wal_start_lsn\n      , EXTRACT(EPOCH FROM stats_reset) AS stats_reset_time\n    FROM pg_catalog.pg_stat_archiver\n  metrics:\n    - archived_count:\n        usage: \"COUNTER\"\n        description: \"Number of WAL files that have been successfully archived\"\n    - failed_count:\n        usage: \"COUNTER\"\n        description: \"Number of failed attempts for archiving WAL files\"\n    - seconds_since_last_archival:\n        usage: \"GAUGE\"\n        description: \"Seconds since the last successful archival operation\"\n    - seconds_since_last_failure:\n        usage: \"GAUGE\"\n        description: \"Seconds since the last failed archival operation\"\n    - last_archived_time:\n        usage: \"GAUGE\"\n        description: \"Epoch of the last time WAL archiving succeeded\"\n    - last_failed_time:\n        usage: \"GAUGE\"\n        description: \"Epoch of the last time WAL archiving failed\"\n    - last_archived_wal_start_lsn:\n        usage: \"GAUGE\"\n        description: \"Archived WAL start LSN\"\n    - last_failed_wal_start_lsn:\n        usage: \"GAUGE\"\n        description: \"Last failed WAL LSN\"\n    - stats_reset_time:\n        usage: \"GAUGE\"\n        description: \"Time at which these statistics were last reset\"\n\npg_stat_bgwriter:\n  query: |\n    SELECT checkpoints_timed\n      , checkpoints_req\n      , checkpoint_write_time\n      , checkpoint_sync_time\n      , buffers_checkpoint\n      , buffers_clean\n      , maxwritten_clean\n      , buffers_backend\n      , buffers_backend_fsync\n      , buffers_alloc\n    FROM pg_catalog.pg_stat_bgwriter\n  metrics:\n    - checkpoints_timed:\n        usage: \"COUNTER\"\n        description: \"Number of scheduled checkpoints that have been performed\"\n    - checkpoints_req:\n        usage: \"COUNTER\"\n        description: \"Number of requested checkpoints that have been performed\"\n    - checkpoint_write_time:\n        usage: \"COUNTER\"\n        description: \"Total amount of time that has been spent in the portion of checkpoint processing where files are written to disk, in milliseconds\"\n    - checkpoint_sync_time:\n        usage: \"COUNTER\"\n        description: \"Total amount of time that has been spent in the portion of checkpoint processing where files are synchronized to disk, in milliseconds\"\n    - buffers_checkpoint:\n        usage: \"COUNTER\"\n        description: \"Number of buffers written during checkpoints\"\n    - buffers_clean:\n        usage: \"COUNTER\"\n        description: \"Number of buffers written by the background writer\"\n    - maxwritten_clean:\n        usage: \"COUNTER\"\n        description: \"Number of times the background writer stopped a cleaning scan because it had written too many buffers\"\n    - buffers_backend:\n        usage: \"COUNTER\"\n        description: \"Number of buffers written directly by a backend\"\n    - buffers_backend_fsync:\n        usage: \"COUNTER\"\n        description: \"Number of times a backend had to execute its own fsync call (normally the background writer handles those even when the backend does its own write)\"\n    - buffers_alloc:\n        usage: \"COUNTER\"\n        description: \"Number of buffers allocated\"\n\npg_stat_database:\n  query: |\n    SELECT datname\n      , xact_commit\n      , xact_rollback\n      , blks_read\n      , blks_hit\n      , tup_returned\n      , tup_fetched\n      , tup_inserted\n      , tup_updated\n      , tup_deleted\n      , conflicts\n      , temp_files\n      , temp_bytes\n      , deadlocks\n      , blk_read_time\n      , blk_write_time\n    FROM pg_catalog.pg_stat_database\n  metrics:\n    - datname:\n        usage: \"LABEL\"\n        description: \"Name of this database\"\n    - xact_commit:\n        usage: \"COUNTER\"\n        description: \"Number of transactions in this database that have been committed\"\n    - xact_rollback:\n        usage: \"COUNTER\"\n        description: \"Number of transactions in this database that have been rolled back\"\n    - blks_read:\n        usage: \"COUNTER\"\n        description: \"Number of disk blocks read in this database\"\n    - blks_hit:\n        usage: \"COUNTER\"\n        description: \"Number of times disk blocks were found already in the buffer cache, so that a read was not necessary (this only includes hits in the PostgreSQL buffer cache, not the operating system's file system cache)\"\n    - tup_returned:\n        usage: \"COUNTER\"\n        description: \"Number of rows returned by queries in this database\"\n    - tup_fetched:\n        usage: \"COUNTER\"\n        description: \"Number of rows fetched by queries in this database\"\n    - tup_inserted:\n        usage: \"COUNTER\"\n        description: \"Number of rows inserted by queries in this database\"\n    - tup_updated:\n        usage: \"COUNTER\"\n        description: \"Number of rows updated by queries in this database\"\n    - tup_deleted:\n        usage: \"COUNTER\"\n        description: \"Number of rows deleted by queries in this database\"\n    - conflicts:\n        usage: \"COUNTER\"\n        description: \"Number of queries canceled due to conflicts with recovery in this database\"\n    - temp_files:\n        usage: \"COUNTER\"\n        description: \"Number of temporary files created by queries in this database\"\n    - temp_bytes:\n        usage: \"COUNTER\"\n        description: \"Total amount of data written to temporary files by queries in this database\"\n    - deadlocks:\n        usage: \"COUNTER\"\n        description: \"Number of deadlocks detected in this database\"\n    - blk_read_time:\n        usage: \"COUNTER\"\n        description: \"Time spent reading data file blocks by backends in this database, in milliseconds\"\n    - blk_write_time:\n        usage: \"COUNTER\"\n        description: \"Time spent writing data file blocks by backends in this database, in milliseconds\"\n\npg_stat_replication:\n  primary: true\n  query: |\n   SELECT usename\n     , COALESCE(application_name, '') AS application_name\n     , COALESCE(client_addr::text, '') AS client_addr\n     , EXTRACT(EPOCH FROM backend_start) AS backend_start\n     , COALESCE(pg_catalog.age(backend_xmin), 0) AS backend_xmin_age\n     , pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), sent_lsn) AS sent_diff_bytes\n     , pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), write_lsn) AS write_diff_bytes\n     , pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), flush_lsn) AS flush_diff_bytes\n     , COALESCE(pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), replay_lsn),0) AS replay_diff_bytes\n     , COALESCE((EXTRACT(EPOCH FROM write_lag)),0)::float AS write_lag_seconds\n     , COALESCE((EXTRACT(EPOCH FROM flush_lag)),0)::float AS flush_lag_seconds\n     , COALESCE((EXTRACT(EPOCH FROM replay_lag)),0)::float AS replay_lag_seconds\n   FROM pg_catalog.pg_stat_replication\n  metrics:\n    - usename:\n        usage: \"LABEL\"\n        description: \"Name of the replication user\"\n    - application_name:\n        usage: \"LABEL\"\n        description: \"Name of the application\"\n    - client_addr:\n        usage: \"LABEL\"\n        description: \"Client IP address\"\n    - backend_start:\n        usage: \"COUNTER\"\n        description: \"Time when this process was started\"\n    - backend_xmin_age:\n        usage: \"COUNTER\"\n        description: \"The age of this standby's xmin horizon\"\n    - sent_diff_bytes:\n        usage: \"GAUGE\"\n        description: \"Difference in bytes from the last write-ahead log location sent on this connection\"\n    - write_diff_bytes:\n        usage: \"GAUGE\"\n        description: \"Difference in bytes from the last write-ahead log location written to disk by this standby server\"\n    - flush_diff_bytes:\n        usage: \"GAUGE\"\n        description: \"Difference in bytes from the last write-ahead log location flushed to disk by this standby server\"\n    - replay_diff_bytes:\n        usage: \"GAUGE\"\n        description: \"Difference in bytes from the last write-ahead log location replayed into the database on this standby server\"\n    - write_lag_seconds:\n        usage: \"GAUGE\"\n        description: \"Time elapsed between flushing recent WAL locally and receiving notification that this standby server has written it\"\n    - flush_lag_seconds:\n        usage: \"GAUGE\"\n        description: \"Time elapsed between flushing recent WAL locally and receiving notification that this standby server has written and flushed it\"\n    - replay_lag_seconds:\n        usage: \"GAUGE\"\n        description: \"Time elapsed between flushing recent WAL locally and receiving notification that this standby server has written, flushed and applied it\"\n\npg_settings:\n  query: |\n    SELECT name,\n    CASE setting WHEN 'on' THEN '1' WHEN 'off' THEN '0' ELSE setting END AS setting\n    FROM pg_catalog.pg_settings\n    WHERE vartype IN ('integer', 'real', 'bool')\n    ORDER BY 1\n  metrics:\n    - name:\n        usage: \"LABEL\"\n        description: \"Name of the setting\"\n    - setting:\n        usage: \"GAUGE\"\n        description: \"Setting value\"\n"},"kind":"ConfigMap","metadata":{"annotations":{},"labels":{"cnpg.io/reload":""},"name":"cnpg-default-monitoring","namespace":"cnpg-system"}}
    creationTimestamp: "2025-09-03T00:43:44Z"
    labels:
      cnpg.io/reload: ""
    name: cnpg-default-monitoring
    namespace: cnpg-system
    resourceVersion: "11693"
    uid: 03848671-1258-4761-b0ce-991936d5ba72
- apiVersion: v1
  data:
    ca-crl.pem: ""
  kind: ConfigMap
  metadata:
    creationTimestamp: "2025-09-03T00:43:44Z"
    labels:
      istio.io/config: "true"
    name: istio-ca-crl
    namespace: cnpg-system
    resourceVersion: "11681"
    uid: 7461144e-de1a-43d0-9614-abb5f9623ab8
- apiVersion: v1
  data:
    root-cert.pem: |
      -----BEGIN CERTIFICATE-----
      MIIC/TCCAeWgAwIBAgIRAKj1qPN3do3ENzmMYsrrepAwDQYJKoZIhvcNAQELBQAw
      GDEWMBQGA1UEChMNY2x1c3Rlci5sb2NhbDAeFw0yNTA5MDMwMDQwMDJaFw0zNTA5
      MDEwMDQwMDJaMBgxFjAUBgNVBAoTDWNsdXN0ZXIubG9jYWwwggEiMA0GCSqGSIb3
      DQEBAQUAA4IBDwAwggEKAoIBAQDASNnK0tf3x5wWEwWuBYOmFQ/VPTewugzJ/EbR
      3NFVhbjV/9wFAr3mfRkmMZHQuVxtVsUDtKK+UwIu0eOBKU2lC8Gr7agv1iOOkeq/
      kcZxaigC9ma8JbUBYhBvbpHhd1JNEGNV2RM6HKzvwjxXGXBdskVtRMWJuJB5y9Pf
      NLJmvLGFVOp+gxSa5Vb3DDcJ+ir4iDvu7wCMCPbT30MMkot4OpUvdnKVdYufWIG1
      01ZjnOhNldkoxEt1RHzk2HmnKp/24Ye7ImeC+M3fDptRXJclySHVsctDxJKJRLvu
      edbQdE283U/nnQ7e5f2lZrVX1EG4OG3mySgo8Lxh+iXZ9/bfAgMBAAGjQjBAMA4G
      A1UdDwEB/wQEAwICBDAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBT6xO8FEUel
      jaUHcSdGcV6xu5JjYjANBgkqhkiG9w0BAQsFAAOCAQEABhu+7t50SQpyDEH2gXIe
      MU+ykT5ov4IpNYUmirbgwgm/paGBuSka8WADps6WqvIZbiHr138aZY2uQiOhJFFy
      crTlvklPIshECa2D79jZYQWyfJfCKI2zja1kZvzFOTOpTVEj2ym0eqFVVkvttxzp
      sl+5vslqDvbp9V1lq2al0w2Dzveu1IObxXtnWzNYZTAv5JS/bkv8Nnko1+3uJxm/
      r/q2dqW7P/fOyhtshTkw1d+mYFGkpHAxyUUPU5RgBUNEPsTY2dWfFAA0uDRuywv9
      PR3MyncyODe1753dczkqh3WQ9OQFwFJbQ4xp6CflY/r3VnBOZW4s2rUHuibgH13J
      hQ==
      -----END CERTIFICATE-----
  kind: ConfigMap
  metadata:
    creationTimestamp: "2025-09-03T00:43:44Z"
    labels:
      istio.io/config: "true"
    name: istio-ca-root-cert
    namespace: cnpg-system
    resourceVersion: "11679"
    uid: 9038ea92-aea7-43f1-880c-27910c12d911
- apiVersion: v1
  data:
    ca.crt: |
      -----BEGIN CERTIFICATE-----
      MIIDBTCCAe2gAwIBAgIIMMYq2AaEuqAwDQYJKoZIhvcNAQELBQAwFTETMBEGA1UE
      AxMKa3ViZXJuZXRlczAeFw0yNTA5MDIyMzA0MzJaFw0zNTA4MzEyMzA5MzJaMBUx
      EzARBgNVBAMTCmt1YmVybmV0ZXMwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEK
      AoIBAQDQZPTv1qUWMYzMd+82eZZkoQzofbS+FOUCnqcmFmagGMaOuWqHit1NX5KE
      GjDS0DBI0sTk0GiRPLPsNoehZexKRC0xsN9RVsE2gEj75pT7oLvP1BxbFI9/X5gv
      wQY8z6IJ3ORA8iND99pL6Re1MATiA7CJW/3kdwZgo93+mhirLRTolvFsg/b7kH1v
      SJ+GqSQB5Jr5EpGZ1PLoeJuR7pTNEuD74KRSmhu1hM6RubDefS2aG4j1zZILHKDf
      uzxYHm99XNzkGxeDFd3TLcUyYk7qutfurAapoCXaGuQxdG7wI1IlHx1WRArDCGvB
      Z+1DyLYlXrJBiCO2P4maMi41BLe3AgMBAAGjWTBXMA4GA1UdDwEB/wQEAwICpDAP
      BgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBStBvTyw8p/O+SZtwZdO4Di7BTSvjAV
      BgNVHREEDjAMggprdWJlcm5ldGVzMA0GCSqGSIb3DQEBCwUAA4IBAQB8zOG/3K9d
      nZpNeciU+jxRs8mi2KyNrBN5tVvHzRghPUewIRJuKTe/0o12sGTZwFQNaqu1I+zR
      uZe4hVB7VljKfXlpTFWv+CQZztOOgodQdkGzHgl1hxEkTCEO9koTqTf32AbUjmCv
      8Lla3rJh77N1Mh8lIfOWebWM4OhaYRAKo/6/Vmc02JMuR4+x+vblcI6pmTQlHPjl
      i5m0DvFaRp+xLPDujuAm0lhCejRyXB6Y5BhAGFH3DBUuCCytDcZCyINe1pfz3jux
      OZz6hTCT2iAR2ceDb0BqVfD5R5GSg7I5xtXHzFhEYdWAObulsLjrcrGjTljVw6Aj
      pvYaGh0uEzDb
      -----END CERTIFICATE-----
  kind: ConfigMap
  metadata:
    annotations:
      kubernetes.io/description: Contains a CA bundle that can be used to verify the
        kube-apiserver when using internal endpoints such as the internal service
        IP or kubernetes.default.svc. No other usage is guaranteed across distributions
        of Kubernetes clusters.
    creationTimestamp: "2025-09-03T00:43:44Z"
    name: kube-root-ca.crt
    namespace: cnpg-system
    resourceVersion: "11677"
    uid: 44e0f850-b270-4c38-8fc4-426b8abe2528
kind: List
metadata:
  resourceVersion: ""
